#ifndef OPERATOR_H
#define OPERATOR_H

// We assume that for all conditions, their lhs must be metadata (not integer), and their rhs must be integer or IP
// For IN, lhs must be metadata, rhs must be returned values of previous policies; IN does not support && and ||.
bool Program::has_return_val(string val, Policy* pol) {
    if (!pol) return false;
    for (int i = 0; i < pol->get_num_stmts(); i ++) {
        // pol->stmts[i].type->print();
		if (pol->stmts[i].type == "Filter" || pol->stmts[i].type == "When") {
            Branch *b = (Branch *)pol->stmts[i].op;
            if (!b->is_complex){
                if (b->op == "IN") { // .filter([sip IN suspicious])
                    if (b->rhs.find(val)!=b->rhs.npos) return true;
                } else {             // .filter(victimLks.size > 3)
                    if (b->lhs.find(val)!=b->lhs.npos) return true;
                }
            } else {                 // .filter(victimLks.size + 1 > 3)
                if (b->cplx_field1.find(val)!=b->cplx_field1.npos || b->cplx_field2.find(val)!=b->cplx_rhs.npos)
                    return true;
            }
        }
    }
    return false;
}

bool Program::find_dotsize(Policy* pol, string ret_val) {
    if (!pol) return false;
    string pat = ret_val+".size";
    for (int i = 0; i < pol->get_num_stmts(); i ++) {
		if (pol->stmts[i].type == "Filter" || pol->stmts[i].type == "When") {
            Branch *b = (Branch *)pol->stmts[i].op;
            if (b->is_complex && (b->cplx_field1.find(pat) != b->cplx_field1.npos
                        || b->cplx_field2.find(pat) != b->cplx_field2.npos))
                return true;
            else if (b->lhs.find(pat) != b->lhs.npos)
                return true;
        }
    }
    return false;
}

bool Program::has_dotsize(string ret_val) {
    return this->find_dotsize (this->dct_p, ret_val)
            || this->find_dotsize (this->cls_p1, ret_val)
            || this->find_dotsize (this->cls_p2, ret_val)
            || this->find_dotsize (this->mtg_p, ret_val);
}

// The main job is to determine whether we have return val, whether the return val has .size, and the size of the register
bool Program::gen_paranoma(Policy* pol, int from_line){
	string ret_val = ((Panorama*)pol->stmts[from_line].op)->ret_val;
	int window = ((Panorama*)pol->stmts[from_line].op)->window;

    // Determine whether we have return value for this paranoma
    // Approach: search all queries and see whether the variable name appears in filter or when
    // bool has_return = has_return_val (return_val, this->dct_p);
    bool has_return = has_return_val (ret_val, this->dct_p)
                        || has_return_val (ret_val, this->cls_p1)
                        || has_return_val (ret_val, this->cls_p2)
                        || has_return_val (ret_val, this->mtg_p);
    if (!has_return)
        return false;

    // Determine whether we need a size register
    // Approach: Search the rest part of the policy to see whether we have *.size
    // Currently, we only support return_val.size appears in filter or when
    bool has_size = this->has_dotsize(ret_val);

    // Determine the size of the register
    // Approach: link=512, others=65536. Search whether there is a map using link as from
    int register_size = 65536;
    for (int i = 1; i < pol->get_num_stmts(); i ++) {
		if (pol->stmts[i].type == "Map") {
            Map *m = (Map *)pol->stmts[i].op;
            if (m->from[0] == "link"){
                register_size = 512;
                break;
            }
        } else if (pol->stmts[i].type == "Panorama") {
            // We have iterated the whole panorama, should stop before the next one
            break;
        }
    }

    assert(this->registers.add_register(Register(ret_val, 32, register_size)));
    this->returns.push_back(ret_val);
    if (has_size){
        assert(this->registers.add_register(Register(ret_val+"_size", 32, 1)));
        this->returns.push_back(ret_val+"_size");
    }
    // handle return_val that is not generated by reduce---distinct
    int end_line = from_line;
    for (int i = from_line+1; i < pol->get_num_stmts(); i ++) {
		if (pol->stmts[i].type == "Panorama") break;
        end_line++;
    }
    if (end_line == pol->stmts.size()) end_line--;
    if (pol->stmts[end_line].type == "Distinct") {
        string reg_size = ret_val + "_size";
        transform(reg_size.begin(),reg_size.end(),reg_size.begin(),::toupper);
        this->constants.add_const(Constant(reg_size, 32, 65535));
    }
    return true;
}

string Program::gen_map_load (string from, string to) {
    string code = read_file("./templates/template_comp_read_load.p4");
    this->code_func += read_file("./templates/compute_load.p4");
    string read_load = read_file("./templates/template_func_read_load.p4")+"\n";
    read_load = regex_replace(read_load, regex("FROM"), from);
    read_load = regex_replace(read_load, regex("TO"), to);
    this->code_func += read_load;
    return code;
}

bool in_set(string item, vector<string> set) {
    return std::find(set.begin(), set.end(), item) != set.end();
}

bool equal_set (vector<string> set1, vector<string> set2){
    if (set1.size() != set2.size())
        return false;
    for (auto item: set1) {
        if (!in_set(item, set2))
            return false;
    }
    for (auto item: set2) {
        if (!in_set(item, set1))
            return false;
    }
    return true;
}

string Program::gen_map(Policy* pol, int from_line){
    assert(from_line>0 && from_line<pol->get_num_stmts());
    Map *m = (Map *)pol->stmts[from_line].op;
    string code="";

    // map_from = link
    if (m->from[0] == "link"){
        code += gen_map_load(m->from[0], m->to);
    } else {  // map_from = any combination from metadata_bus
        // keys must be in the metadata_bus
        for (auto item : m->from)
            assert(in_metadata(item));
        code += "            meta."+m->to+" = 1;\n";
    }
    // generate new metadata
    this->metadata.add_field(MetadataField(m->to, 32));
    return code;
}

bool Program::cross_pano(Policy* pol, int from_line, string filter_name) {
    bool cross = false;
    for (int i=from_line-1; i>=0; i--){
        if (pol->stmts[i].type == "Zip") {
            Zip *z = (Zip *)pol->stmts[i].op;
            if (z->input1 == filter_name || z->input2 == filter_name) {
                cross = true;
                break;
            }
        }
    }
    return cross;
}

bool Program::filter_on_reg(Policy* pol, int from_line, string filter_name) {
    bool cross = cross_pano(pol, from_line, filter_name);
    for (int i=from_line-1; i>=0; i--){
        if (pol->stmts[i].type == "Reduce") {
            Reduce *r = (Reduce *)pol->stmts[i].op;
            if (r->result == filter_name){
                string reg_name = "reduce_"+r->value+"_to_"+r->result+"_full_wind";
                if (this->in_registers(reg_name))
                    return true;
            }
        } else if (!cross && pol->stmts[i].type == "Panorama") {
            return false;
        }
    }
    return false;
}

bool Program::find_reg_later(Policy* pol, int from_line, string filter_name) {
    for (int i=from_line; i<pol->get_num_stmts(); i++){
        if (pol->stmts[i].type == "Panorama") {
            Panorama *p = (Panorama *)pol->stmts[i].op;
            if (p->ret_val == filter_name)
                return true;
        }
    }
    return false;
}


string Program::lhs_to_reg_prefix(Policy* pol, int from_line, string filter_name) {
    bool cross = cross_pano(pol, from_line, filter_name);
    for (int i=from_line-1; i>=0; i--){
        if (pol->stmts[i].type == "Reduce") {
            Reduce *r = (Reduce *)pol->stmts[i].op;
            if (r->result == filter_name){
                return "reduce_"+r->value+"_to_"+r->result;
            }
        } else if (!cross && pol->stmts[i].type == "Panorama") {
            return "";
        }
    }
    return "";
}

string Program::gen_when_name(When *w, string stage) {
    string key_comb="";
    if (w->keys.size() == 0) { // we don't have key for .when([victimLks.size > 3], fwd=f_reroute)
        key_comb = "standard_metadata_egress_spec";
    } else {
        for (auto item: w->keys)
             key_comb += item+"_";
        key_comb.pop_back();
    }

    string func_name;
    if (w->func == "f_reroute")
        func_name = "func_"+key_comb+"_reroute_"+stage;
    else
        func_name = "func_"+key_comb+"_drop_"+stage;
    return func_name;
}

string Program::gen_when_body(When *w, string func_name, string &code_func) {
    string code="";
    if (w->func == "f_reroute") {
        // add reroute registers
        this->registers.add_register(Register("best_path", 32, 65536));
        this->registers.add_register(Register("flow_nhop", 32, 65536));
        code += "                "+func_name+".apply(hdr, meta, standard_metadata, \\\n";
        code += "                                flow_nhop, \\\n";
        code += "                                best_path);\n";

        string reroute_key="";
        if (w->keys.size()>0) {
            for (auto item: w->keys)
                reroute_key += "meta."+item+", ";
            reroute_key.pop_back();
            reroute_key.pop_back();
        } else { // use the default key
            reroute_key = "standard_metadata.egress_spec";
        }

        string code_reroute = read_file("./templates/template_reroute.p4");
        code_reroute = regex_replace(code_reroute, regex("func_name"), func_name);
        code_reroute = regex_replace(code_reroute, regex("key"), reroute_key);
        code_func += code_reroute;
    }
    // for f_drop
    else {
        code +="                DROP()\n";
    }

    return code;
}

string Program::gen_when(Policy* pol, int from_line, string stage) {
    assert(from_line>0 && from_line<pol->get_num_stmts());
    assert(pol->stmts[from_line].type == "When");
    When *w = (When *)pol->stmts[from_line].op;
    if (w->func == "")
        return "";
    string func_name = gen_when_name(w, stage);
    // the returned code
    string code= gen_when_body(w, func_name, this->code_func);
    return code;
}

bool Program::branch_check(Policy* pol, int from_line, string lhs, string rhs, string op,
                                string cplx_field1, string cplx_field2, vector<string> keys, bool is_complex) {
    bool legal_metadata = false;
    bool legal_register = false;

    if (pol->has_selfzip) return true;

    // Check the IN predicate, lhs is in metadata, rhs is in returned values
    if (!is_complex && op=="IN"){
        for (auto item : keys){
            assert(this->in_metadata(item));
        }
        assert(this->in_return(rhs));
    }
    // Check the filter predicate is in metadata_bus
    else {
        // TODO: This might not be necessary since it can be a number. E.g., 1+2>4
        if (!is_complex){
            string predicate = regex_replace(lhs, regex(".size"), "_size");
            legal_metadata = this->in_metadata(predicate);
        } else {
            string predicate1 = regex_replace(cplx_field1, regex(".size"), "_size");
            string predicate2 = regex_replace(cplx_field2, regex(".size"), "_size");
            legal_metadata = this->in_metadata(predicate1) && this->in_metadata(predicate2);
        }

        // Check the filter predicate is in register_bus
        if (!is_complex){
            string reg_name = lhs;
            legal_register = this->filter_on_reg(pol, from_line, reg_name);
        } else {
            string reg_name1 = cplx_field1;
            string reg_name2 = cplx_field2;
            legal_register = this->filter_on_reg(pol, from_line, reg_name1) && this->filter_on_reg(pol, from_line, reg_name2);
        }

        // assert(legal_metadata || legal_register);
        if (!(legal_metadata || legal_register)) {
            // case like .when ([rerouteip.size == 0]) where rerouteip is defined later
            assert(!is_complex);
            string reg = regex_replace(lhs, regex(".size"), "");
            return this->find_reg_later(pol, from_line, reg);
        }
    }
    return legal_register;
}

string Program::gen_branch_simple_in(Policy* pol, int from_line, string stage, int pano_num, string rhs,
                                vector<string> keys, string func) {
    string code = "";
    string key_comb="";
    for (auto item: keys)
        key_comb += item+"_";
    key_comb.pop_back();
    string filter_name = "filter_"+key_comb+"_in_"+rhs+"_"+stage+to_string(pano_num);
    code += "                "+filter_name+".apply(hdr, meta, standard_metadata, \\\n";
    code += "                            "+rhs+");\n\n";

    // generate code_func
    // We need to determine whether the right hand side is a bitmap or a bloom filter
    // Approach: if lhs=link, it is a bitmap; otherwise, it is a bloom filter

    // hanlde bitmap
    if (keys[0] == "link"){
        string code = read_file("./templates/template_filter_link.p4");
        code = regex_replace(code, regex("FILTER_NAME"), filter_name);
        code = regex_replace(code, regex("RHS"), rhs);
        code = regex_replace(code, regex("STAGE"), stage);
        code = regex_replace(code, regex("PANO_NUM"), to_string(pano_num));
        this->code_func += code + "\n";
    } else { // hanlde bloom filter
        string code_in_bf = read_file("./templates/template_in_bf.p4");
        code_in_bf = regex_replace(code_in_bf, regex("filter_prefix"), filter_name);
        code_in_bf = regex_replace(code_in_bf, regex("reg_name"), rhs);

        // set the size for bloom filters
        string reg_size = rhs + "_size";
        transform(reg_size.begin(),reg_size.end(),reg_size.begin(),::toupper);
        // Has been added in return or reduce
        // pol->stmts[from_line].op->print();
        assert(this->in_constant(reg_size));
        code_in_bf = regex_replace(code_in_bf, regex("\\breg_size\\b"), reg_size);
        code_in_bf = regex_replace(code_in_bf, regex("filter_name"), stage+"_filter"+to_string(pano_num));

        // get the key for bloom filters
        string bf_key="";
        for (auto item : keys)
            bf_key += "meta."+item+", ";
        bf_key.pop_back();
        bf_key.pop_back();
        code_in_bf = regex_replace(code_in_bf, regex("\\bKEY\\b"), bf_key);
        this->code_func += code_in_bf;
    }
    // generate func code
    if (func != ""){
        code +="            if(meta."+stage+"_filter"+to_string(pano_num)+" == 1) {\n";
        code += gen_when(pol, from_line, stage);
        code +="            }\n";
    }
    return code;
}

string Program::gen_empty(Policy* pol, int from_line, string stage, int pano_num, string lhs) {
    string code = "";
    string reg_name =  regex_replace(lhs, regex(".isempty"), "_isempty");

    string filter_name = "filter_"+reg_name+"_"+stage+to_string(pano_num);
    code += "                "+filter_name+".apply(hdr, meta, standard_metadata, \\\n";
    code += "                            "+reg_name+");\n\n";

    string code_func = read_file("./templates/template_filter_empty.p4");
    code_func = regex_replace(code_func, regex("FILTER_NAME"), filter_name);
    code_func = regex_replace(code_func, regex("REG"), reg_name);
    code_func = regex_replace(code_func, regex("STAGE"), stage);
    code_func = regex_replace(code_func, regex("PANO_NUM"), to_string(pano_num+1));
    this->code_func += code_func + "\n";

    return code;
}

string Program::gen_ipset(Policy* pol, int from_line, string stage, int pano_num, string lhs) {
    Branch *b = (Branch*) pol->stmts[from_line].op;

    string code = "";
    string filter_name = "filter_ipset_"+lhs+"_"+stage+to_string(pano_num);
    code += "                "+filter_name+".apply(hdr, meta, standard_metadata);\n\n";

    string code_func = read_file("./templates/template_filter_ipset.p4");
    code_func = regex_replace(code_func, regex("FILTER_NAME"), filter_name);
    code_func = regex_replace(code_func, regex("STAGE"), stage);
    code_func = regex_replace(code_func, regex("\\bKEY\\b"), lhs);
    code_func = regex_replace(code_func, regex("LOW"), to_string(b->ip_start));

    code_func = regex_replace(code_func, regex("HIGH"), to_string(b->ip_end));
    code_func = regex_replace(code_func, regex("PANO_NUM"), to_string(pano_num));
    this->code_func += code_func + "\n";
    return code;
}

string Program::gen_branch_main(Policy* pol, int from_line, string lhs, string cplx_field1, string cplx_field2, string filter_name,
                                    bool is_complex, bool legal_register, bool has_size) {
    string code = "";
    // generate filter code
    if (LINK_REG && is_filter_on_link(pol, lhs)){
        code += "                filter_"+filter_name+".apply(hdr, meta, standard_metadata, \\\n";
        code += "                            link_thresh";
    } else {
        code += "                filter_"+filter_name+".apply(hdr, meta, standard_metadata";
    }

    if (!legal_register){
        if (!has_size)
            code += ");\n\n";
        else
            code += ", \\\n                            "+regex_replace(lhs, regex(".size"), "_size")+");\n\n";

    } else {
        if (!is_complex) {
            string reg_name = this->lhs_to_reg_prefix(pol, from_line, lhs);
            code +=", \\\n                            "+reg_name+"_cur_wind_pass);\n\n";
        } else {
            string reg_name1 = this->lhs_to_reg_prefix(pol, from_line, cplx_field1);
            string reg_name2 = this->lhs_to_reg_prefix(pol, from_line, cplx_field2);
            // handle the case where .zip([sip], [flowsz], [flowsz])
            if (pol->has_selfzip) {
                reg_name1 = "reduce_"+pol->szip.reduce_value+"_to_"+pol->szip.input1;
                reg_name1 = reg_name1.substr(0, reg_name1.length()-1);
                code +=", \\\n                            "+reg_name1+"_cur_wind_pass);\n\n";
            } else {
                assert(reg_name1!="" && reg_name2!="");
                code +=", \\\n                            "+reg_name1+"_cur_wind_pass, \\\n";
                code +="                            "+reg_name2+"_cur_wind_pass);\n\n";
            }
        }
    }
    return code;
}

string Program::gen_branch_condition(Policy* pol, int from_line, string lhs, string rhs, string op, string cplx_field1, string cplx_field2,
                                        string cplx_op, string cplx_arithop, string cplx_rhs, bool is_complex, bool legal_register) {
    string condition="";
    if (!is_complex){
        string lhs_tmp = lhs;
        // change reduce metadata
        if (legal_register){
            lhs_tmp = this->lhs_to_reg_prefix(pol, from_line, lhs)+"_full";
            assert(lhs_tmp != "");
        }
        condition = "meta."+regex_replace(lhs_tmp, regex(".size"), "_size")+" "+op+" "+rhs;
    } else {
        string lhs1 = cplx_field1;
        string lhs2 = cplx_field2;
        if (pol->stmts[from_line-1].type == "Zip"){
            condition = "meta."+lhs1+"_val "+cplx_arithop+" meta."+lhs2+"_val "+cplx_op+" "+cplx_rhs;
            if (cplx_arithop == "-") {
                condition += " && meta."+lhs1+"_val > meta."+lhs2+"_val";
            }
        } else {
            if (legal_register){
                lhs1 = this->lhs_to_reg_prefix(pol, from_line, cplx_field1)+"_full";
                lhs2 = this->lhs_to_reg_prefix(pol, from_line, cplx_field2)+"_full";
                assert(lhs1 != "_full" || lhs2 != "_full");
            }
            condition = "meta."+regex_replace(lhs1, regex(".size"), "_size")+" "+cplx_arithop+" meta."+regex_replace(lhs2, regex(".size"), "_size")+" "+cplx_op+" "+cplx_rhs;
        }
    }
    return condition;
}

string Program::gen_branch(Policy* pol, int from_line, string stage, string type, int pano_num) {
    assert(from_line>0 && from_line<pol->get_num_stmts());
    assert(type == "Filter" || type == "When");

    Branch *b = (Branch *)pol->stmts[from_line].op;
    bool is_complex = b->is_complex;
    string lhs = b->lhs;
    string rhs = b->rhs;
    string op = b->op;
    string cplx_field1 = b->cplx_field1;
    string cplx_field2 = b->cplx_field2;
    string cplx_arithop = b->cplx_arithop;
    string cplx_op = b->cplx_op;
    string cplx_rhs = b->cplx_rhs;
    vector<string> keys = b->keys;
    string ret_val = ((Panorama*)pol->stmts[0].op)->ret_val;
    string func;
    if (type == "When")
        func = ((When *)pol->stmts[from_line].op)->func;
    else
        func = "";

    if (b->is_ipset)
        return gen_ipset(pol, from_line, stage, pano_num, lhs);

    bool legal_register = branch_check(pol, from_line, lhs, rhs, op, cplx_field1, cplx_field2, keys, is_complex);

    // the return code
    string code="";
    // handle isempty
    if(type == "When" && ((When*)b)->has_empty)
        return gen_empty(pol, from_line, stage, pano_num, lhs);

    // handle op = IN
    if (!is_complex && op == "IN")
        return gen_branch_simple_in(pol, from_line, stage, pano_num, rhs, keys, func);


    // determine the filter name
    string filter_name = "";
    if (is_complex)
        filter_name = cplx_field1+"_"+cplx_field2+"_"+stage+to_string(pano_num)+"_"+to_string(from_line);
    else
        filter_name = lhs+"_"+stage+to_string(pano_num)+"_"+to_string(from_line);
    // replace .size with _size
    filter_name = regex_replace(filter_name, regex(".size"), "_size");

    // .size can only appear at simple condition
    bool has_size = false;
    if (!is_complex) {
        has_size = lhs.find(".size") != lhs.npos;
    }

    // handle other ops, e.g., >, <, etc.
    code += gen_branch_main(pol, from_line, lhs, cplx_field1, cplx_field2, filter_name,
                                is_complex, legal_register, has_size);

    if (func != ""){
        code +="            if(meta."+stage+"_filter"+to_string(pano_num+1)+" == 1) {\n";
        code += gen_when(pol, from_line, stage);
        code +="            }\n";
    }

    // generate func_code
    if (stage == "detection" && is_filter_on_link(pol, lhs)){
        assert(!is_complex);
        if (LINK_REG){
            string fc = read_file("./templates/template_dct_filter_link_reg.p4");
            fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
            fc = regex_replace(fc, regex("LHS"), lhs);
            fc = regex_replace(fc, regex("STAGE"), stage);
            int next_num = type == "When"?pano_num+1:pano_num;
            fc = regex_replace(fc, regex("PANO_NUM"), to_string(next_num));
            this->code_func += fc+"\n";
            return code;
        } else {
            int thresh_int = (int)(atof(rhs.c_str())*LINK_BANDWIDTH);
            thresh_int = thresh_int << 16;
            string fc = read_file("./templates/template_dct_filter_link_num.p4");
            fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
            fc = regex_replace(fc, regex("LHS"), lhs);
            fc = regex_replace(fc, regex("OP"), lhs);
            fc = regex_replace(fc, regex("THRESH"), lhs);
            fc = regex_replace(fc, regex("STAGE"), stage);
            int next_num = type == "When"?pano_num+1:pano_num;
            fc = regex_replace(fc, regex("PANO_NUM"), to_string(next_num));
            this->code_func += fc+"\n";
            return code;
        }
    } else {
        string condition = gen_branch_condition(pol, from_line, lhs, rhs, op, cplx_field1, cplx_field2,
                                        cplx_op, cplx_arithop, cplx_rhs, is_complex, legal_register);
        // filter based on normal data structure
        if (!legal_register){
            if (!has_size) {
                string fc = read_file("./templates/template_filter_noreg_nosize.p4");
                fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
                fc = regex_replace(fc, regex("CONDITION"), condition);
                fc = regex_replace(fc, regex("STAGE"), stage);
                int next_num = type == "When"?pano_num+1:pano_num;
                fc = regex_replace(fc, regex("PANO_NUM"), to_string(next_num));
                this->code_func += fc+"\n";
                return code;
            } else {
                string reg_name = regex_replace(lhs, regex(".size"), "_size");
                string fc = read_file("./templates/template_filter_noreg_size.p4");
                fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
                fc = regex_replace(fc, regex("CONDITION"), condition);
                fc = regex_replace(fc, regex("STAGE"), stage);
                int next_num = type == "When"?pano_num+1:pano_num;
                fc = regex_replace(fc, regex("PANO_NUM"), to_string(next_num));
                fc = regex_replace(fc, regex("REG_NAME"), reg_name);
                this->code_func += fc+"\n";
                return code;
            }

        }
        // filter based on normal register
        else {
            if (!is_complex) {
                string reg_name = this->lhs_to_reg_prefix(pol, from_line, lhs);
                string fc = read_file("./templates/template_filter_reg_simple.p4");
                fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
                fc = regex_replace(fc, regex("CONDITION"), condition);
                fc = regex_replace(fc, regex("STAGE"), stage);
                int next_num = type == "When"?pano_num+1:pano_num;
                fc = regex_replace(fc, regex("PANO_NUM"), to_string(next_num));
                fc = regex_replace(fc, regex("REG_NAME"), reg_name);
                this->code_func += fc+"\n";
                return code;
            } else {
                string reg_name1, reg_name2;
                string fc;
                if (pol->has_selfzip && pol->stmts[from_line-1].type=="Zip" && cplx_field1==pol->szip.input1&& cplx_field2==pol->szip.input2){
                    reg_name1 = this->lhs_to_reg_prefix(pol, from_line, cplx_field1.substr(0,cplx_field1.length()-1))+"1";
                    reg_name2 = this->lhs_to_reg_prefix(pol, from_line, cplx_field2.substr(0,cplx_field2.length()-1))+"2";
                    fc =read_file("./templates/template_filter_reg_cplx4.p4");
                    fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
                    fc = regex_replace(fc, regex("CONDITION"), condition);
                    fc = regex_replace(fc, regex("STAGE"), stage);
                    int next_num = type == "When"?pano_num+1:pano_num;
                    fc = regex_replace(fc, regex("PANO_NUM"), to_string(next_num));
                    fc = regex_replace(fc, regex("REG_NAME"), reg_name1.substr(0, reg_name1.length()-1));
                } else {
                    reg_name1 = this->lhs_to_reg_prefix(pol, from_line, cplx_field1);
                    reg_name2 = this->lhs_to_reg_prefix(pol, from_line, cplx_field2);
                    fc =read_file("./templates/template_filter_reg_cplx.p4");
                    fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
                    fc = regex_replace(fc, regex("CONDITION"), condition);
                    fc = regex_replace(fc, regex("STAGE"), stage);
                    int next_num = type == "When"?pano_num+1:pano_num;
                    fc = regex_replace(fc, regex("PANO_NUM"), to_string(next_num));
                    fc = regex_replace(fc, regex("REG_NAME1"), reg_name1);
                    fc = regex_replace(fc, regex("REG_NAME2"), reg_name2);
                }
                this->code_func += fc+"\n";
                return code;
            }
        }
    }
    return code;
}

string Program::gen_return(Policy* pol, int from_line, string stage, int pano_num){
    string ret_val;
	for (int i=from_line; i>=0; i--){
        if (pol->stmts[i].type == "Panorama") {
            ret_val = ((Panorama*)pol->stmts[i].op)->ret_val;
            break;
        }
    }

    assert(from_line>0 && from_line<pol->get_num_stmts());
    Filter *f = (Filter *)pol->stmts[from_line].op;
    // determine the filter name
    string filter_name = "";
    if (f->is_complex)
        filter_name = f->cplx_field1+"_"+f->cplx_field2;
    else
        filter_name = f->lhs;

    bool has_size = this->has_dotsize(ret_val);
    // generate func code
    // determine is linkset or other registers
    // linkset uses bitmap while others use bloom filters
    bool bitmap = false;
    for (int i = 0; i < from_line; i ++) {
        if (pol->stmts[i].type == "Map") {
            Map *m = (Map *)pol->stmts[i].op;
            if (f->is_complex) {
                if (m->from[0] == "link" && (m->to == f->cplx_field1 || m->to == f->cplx_field2)){
                    bitmap = true; break;
                }
            } else {
                if (m->from[0] == "link" && m->to == f->lhs){
                    bitmap = true; break;
                }
            }
        }
    }

    // generate p4 code
    string code="                if (meta."+stage+"_filter"+to_string(pano_num)+" == 1){\n"
                "                    filter_"+filter_name+"_return.apply(hdr, meta, standard_metadata, \\\n";
    if (has_size){
        code += "                                "+ret_val+", \\\n";
        code += "                                "+ret_val+"_size);\n";
    } else {
        code += "                                "+ret_val+");\n";
    }
    code +="                }\n";
    if (bitmap) {
        string fname;
        if (has_size) {
            fname = "./templates/template_filter_bitmap_size.p4";
            // add the return_val.size to the metadata bus, later filter will access to it
            this->metadata.add_field(MetadataField(ret_val+"_size", 32));
        }
        else {
            fname = "./templates/template_filter_bitmap_nosize.p4";
        }

        string fc = read_file("./templates/template_filter_bitmap_size.p4");
        fc = regex_replace(fc, regex("FILTER_NAME"), filter_name);
        fc = regex_replace(fc, regex("STAGE"), stage);
        fc = regex_replace(fc, regex("PANO_NUM"), to_string(pano_num));
        fc = regex_replace(fc, regex("REG_NAME"), ret_val);
        this->code_func += fc+"\n";
        return code;
    }
    // for other registers
    else {
        string code_return = read_file("./templates/template_reduce_return.p4");
        code_return = regex_replace(code_return, regex("filter_prefix"), "filter_"+filter_name);
        code_return = regex_replace(code_return, regex("reg_name"), ret_val);

        // set the size for bloom filters
        string reg_size = ret_val + "_size";
        transform(reg_size.begin(),reg_size.end(),reg_size.begin(),::toupper);
        this->constants.add_const(Constant(reg_size, 32, 65535));
        code_return = regex_replace(code_return, regex("reg_size"), reg_size);

        // get the key for bloom filters
        int line = -1;
        for (int i=from_line-1; i>=0; i--){
            if (pol->stmts[i].type == "Reduce" || pol->stmts[i].type == "Zip"){
                line = i;
                break;
            } else if (pol->stmts[i].type == "Panorama"){
                break;
            }
        }
        assert(line>0);
        string bf_key="";
        if (pol->stmts[line].type == "Reduce") {
            Reduce *r = (Reduce *)pol->stmts[line].op;
            for (auto item: r->key)
                bf_key += "meta."+item+", ";
        }
        else if (pol->stmts[line].type == "Zip") {
            Zip *r = (Zip *)pol->stmts[line].op;
            for (auto item: r->key)
                bf_key += "meta."+item+", ";
        }
        bf_key.pop_back();
        bf_key.pop_back();
        code_return = regex_replace(code_return, regex("\\bKEY\\b"), bf_key);
        this->code_func += code_return;
    }
    return code;
}

string Program::gen_rd_window(string stage, int window, string reg_prefix, string indent1,
                                string indent2, string sketch_size, string &func_code, bool four_wind){
    assert(this->registers.add_register(Register(reg_prefix+"_clean_offset", 32, 65536)));
    assert(this->registers.add_register(Register(reg_prefix+"_cur_wind_pass", 32, 65536)));
    assert(this->registers.add_register(Register(reg_prefix+"_cur_wind", 32, 65536)));
    assert(this->registers.add_register(Register(reg_prefix+"_full_wind", 32, 65536)));
    assert(this->registers.add_register(Register(reg_prefix+"_clean_wind", 32, 65536)));

    this->constants.add_const(Constant(sketch_size, 32, 65535));
    this->metadata.add_field(MetadataField(reg_prefix+"_wind_updated", 32));
    this->metadata.add_field(MetadataField(reg_prefix+"_full", 32));


    // generate reduce window
    string code = "";
    code += "\n";
    code += indent1+reg_prefix+"_window.apply(hdr, meta, standard_metadata, \\\n";
    code += indent2+reg_prefix+"_cur_wind,  \\\n";
    code += indent2+reg_prefix+"_cur_wind_pass,  \\\n";
    code += indent2+reg_prefix+"_full_wind,  \\\n";
    code += indent2+reg_prefix+"_clean_wind,  \\\n";
    code += indent2+reg_prefix+"_clean_offset,  \\\n";
    if (stage == "classification")
        code += indent2+"c_wind_last_ts);\n\n";
    else if (stage == "classification1")
        code += indent2+"c_wind_last_ts_p1);\n\n";
    else
        code += indent2+"c_wind_last_ts_p2);\n\n";

    string fname;
    if (four_wind)
        fname = "./templates/template_window4.p4";
    else
        fname = "./templates/template_window.p4";
    string code_window = read_file(fname);
    code_window = regex_replace(code_window, regex("register_name_prefix"), reg_prefix);
    if (stage == "classification")
        code_window = regex_replace(code_window, regex("last_ts"), "c_wind_last_ts");
    else if (stage == "classification1") {
        code_window = regex_replace(code_window, regex("last_ts"), "c_wind_last_ts_p1");
        code_window = regex_replace(code_window, regex("c_wind_interval"), "c_wind_interval_p1");
    } else {
        code_window = regex_replace(code_window, regex("last_ts"), "c_wind_last_ts_p2");
        code_window = regex_replace(code_window, regex("c_wind_interval"), "c_wind_interval_p2");
    }


    code_window = regex_replace(code_window, regex("reg_size"), sketch_size);
    code_window = regex_replace(code_window, regex("window_size"), to_string(window));
    func_code += code_window;
    return code;
}

string Program::gen_reduce(Policy* pol, int from_line, string stage, int window){
    assert(from_line>0 && from_line<pol->get_num_stmts());
    Reduce *r = (Reduce *)pol->stmts[from_line].op;

    // The return code
    string code="";

    vector<string> key = r->key;
    string result = r->result;
    string value = r->value;

    // .reduce([*], [reroute], [1])
    if (key[0]=="*" && value=="1") {
        assert(this->in_registers(result));
        code += "                "+result+".write(0, 1);\n";
        return code;
    }

    assert(this->in_metadata(value));
    // all keys must be in the metadata_bus
    for (auto item : key)
        assert(this->in_metadata(item));

    // add sketch registers to the register_bus
    string reg_prefix = "reduce_"+value+"_to_"+result;
    int reg_count = pol->has_selfzip?4:3;
    for (int i=0; i<3; i++)
        for (int j=0; j<reg_count; j++)
            assert(this->registers.add_register(Register(reg_prefix+"_s"+to_string(i)+"_w"+to_string(j), 32, 65536)));

    string indent1 = "            ";
    string indent2 = "                                ";
    string indent3 = "                  ";
    string sketch_size = reg_prefix + "_size";
    transform(sketch_size.begin(),sketch_size.end(),sketch_size.begin(),::toupper);
    code += gen_rd_window(stage, window, reg_prefix, indent1, indent2, sketch_size, this->code_func, pol->has_selfzip);

    string params_reg_wind;
    params_reg_wind += indent2+reg_prefix+"_s0_w0, "+reg_prefix+"_s1_w0, "+reg_prefix+"_s2_w0, \\\n";
    params_reg_wind += indent2+reg_prefix+"_s0_w1, "+reg_prefix+"_s1_w1, "+reg_prefix+"_s2_w1, \\\n";
    if (pol->has_selfzip) {
        params_reg_wind += indent2+reg_prefix+"_s0_w2, "+reg_prefix+"_s1_w2, "+reg_prefix+"_s2_w2, \\\n";
        params_reg_wind += indent2+reg_prefix+"_s0_w3, "+reg_prefix+"_s1_w3, "+reg_prefix+"_s2_w3);\n\n";
    } else {
        params_reg_wind += indent2+reg_prefix+"_s0_w2, "+reg_prefix+"_s1_w2, "+reg_prefix+"_s2_w2);\n\n";
    }

    // update current window
    code += indent1+reg_prefix+"_update.apply(hdr, meta, standard_metadata, \\\n";
    code += indent2+reg_prefix+"_cur_wind,  \\\n";
    code += params_reg_wind;

    string func_params_reg_wind;
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s0_w0,\n";
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s1_w0,\n";
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s2_w0,\n";
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s0_w1,\n";
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s1_w1,\n";
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s2_w1,\n";
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s0_w2,\n";
    func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s1_w2,\n";
    if (pol->has_selfzip) {
        func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s2_w2,\n";
        func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s0_w3,\n";
        func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s1_w3,\n";
        func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s2_w3";
    } else {
        func_params_reg_wind += indent3 + "in register<bit<32>> register_name_prefix_s2_w2";
    }


	string code_update = read_file("./templates/template_reduce_update.p4");
    // get hash keys
    string sketch_key="";
    for (auto item : key)
        sketch_key += "meta."+item+", ";
    sketch_key.pop_back();
    sketch_key.pop_back();
    string update_way = value=="pktlen"?  "standard_metadata.packet_length":"meta."+value;
    code_update = regex_replace(code_update, regex("PARAMS"), func_params_reg_wind);
    code_update = regex_replace(code_update, regex("register_name_prefix"), reg_prefix);
    code_update = regex_replace(code_update, regex("key"), sketch_key);
    code_update = regex_replace(code_update, regex("reg_size"), sketch_size);
    code_update = regex_replace(code_update, regex("UPDATE"), update_way);
    this->code_func += code_update;


    // clean the other one
    code += indent1+reg_prefix+"_clean.apply(hdr, meta, standard_metadata, \\\n";
    code += indent2+reg_prefix+"_cur_wind_pass, \\\n";
    code += indent2+reg_prefix+"_clean_wind, \\\n";
    code += indent2+reg_prefix+"_clean_offset, \\\n";
    code += params_reg_wind;

	string code_clean = read_file("./templates/template_reduce_clean.p4");
    code_clean = regex_replace(code_clean, regex("PARAMS"), func_params_reg_wind);
    code_clean = regex_replace(code_clean, regex("register_name_prefix"), reg_prefix);
    code_clean = regex_replace(code_clean, regex("reg_size"), sketch_size);
    this->code_func += code_clean;


    // read the full window
    code += indent1+reg_prefix+"_read.apply(hdr, meta, standard_metadata, \\\n";
    code += indent2+reg_prefix+"_full_wind,  \\\n";
    code += params_reg_wind;

	string code_read = read_file("./templates/template_reduce_read.p4");
    code_read = regex_replace(code_read, regex("PARAMS"), func_params_reg_wind);
    code_read = regex_replace(code_read, regex("register_name_prefix"), reg_prefix);
    code_read = regex_replace(code_read, regex("key"), sketch_key);
    code_read = regex_replace(code_read, regex("reg_size"), sketch_size);
    this->code_func += code_read;

    return code;
}

string Program::get_distinct_ret(Policy* pol, int from_line) {
    bool has_ret = false;
    if (from_line==pol->get_num_stmts()||(from_line<pol->get_num_stmts()&&pol->stmts[from_line+1].type=="Panorama")){
        for(int i=from_line-1; i>=0; i--){
            if (pol->stmts[i].type=="Panorama")
                return ((Panorama*)pol->stmts[i].op)->ret_val;
        }
    }
    return "";
}

string Program::gen_distinct(Policy* pol, int from_line, string stage, int window, int pano_num){
    assert(from_line>0 && from_line<pol->get_num_stmts());
    Distinct *dst = (Distinct *)pol->stmts[from_line].op;

    vector<string> keys = dst->keys;
    // The return code
    string code="";

    // all keys must be in the metadata_bus
    for (auto item : keys)
        assert(this->in_metadata(item));

    // add sketch registers to the register_bus
    string reg_prefix = "distinct";
    for (auto item : keys)
        reg_prefix += "_"+item;

    for (int i=0; i<3; i++)
        assert(this->registers.add_register(Register(reg_prefix+"_w"+to_string(i), 32, 65536)));


    string indent1 = "            ";
    string indent2 = "                                ";
    string sketch_size = reg_prefix + "_size";
    transform(sketch_size.begin(),sketch_size.end(),sketch_size.begin(),::toupper);
    code += gen_rd_window(stage, window, reg_prefix, indent1, indent2, sketch_size, this->code_func, false);


    // update current window
    code += indent1+reg_prefix+"_update.apply(hdr, meta, standard_metadata, \\\n";
    code += indent2+reg_prefix+"_cur_wind,  \\\n";
    code += indent2+reg_prefix+"_w0, \\\n";
    code += indent2+reg_prefix+"_w1, \\\n";
    code += indent2+reg_prefix+"_w2);\n\n";

	string code_update = read_file("./templates/template_distinct_update.p4");
    // get hash keys
    string sketch_key="";
    for (auto item : keys)
        sketch_key += "meta."+item+", ";
    sketch_key.pop_back();
    sketch_key.pop_back();

    code_update = regex_replace(code_update, regex("register_name_prefix"), reg_prefix);
    code_update = regex_replace(code_update, regex("key"), sketch_key);
    code_update = regex_replace(code_update, regex("reg_size"), sketch_size);
    code_update = regex_replace(code_update, regex("STAGE"), stage);
    code_update = regex_replace(code_update, regex("PANO_NUM"), to_string(pano_num));
    this->code_func += code_update;

    // clean the other one
    code += indent1+reg_prefix+"_clean.apply(hdr, meta, standard_metadata, \\\n";
    code += indent2+reg_prefix+"_cur_wind_pass, \\\n";
    code += indent2+reg_prefix+"_clean_wind, \\\n";
    code += indent2+reg_prefix+"_clean_offset, \\\n";
    code += indent2+reg_prefix+"_w0, \\\n";
    code += indent2+reg_prefix+"_w1, \\\n";
    code += indent2+reg_prefix+"_w2);\n\n";

    string ret_name = get_distinct_ret(pol, from_line);
    if (ret_name!=""){
        code += indent1+ret_name+"_isempty.write(0, 1);\n";
        assert(this->registers.add_register(Register(ret_name+"_isempty", 32, 1)));
    }

	string code_clean = read_file("./templates/template_distinct_clean.p4");
    code_clean = regex_replace(code_clean, regex("register_name_prefix"), reg_prefix);
    code_clean = regex_replace(code_clean, regex("reg_size"), sketch_size);
    this->code_func += code_clean;

    return code;
}

extern int get_zip_reduce_line(Policy* pol, string input);
extern bool check_zip_cross(Policy* pol, string input);

string Program::gen_zip(Policy* pol, int from_line, string stage){
    assert(from_line>0 && from_line<pol->get_num_stmts());
    Zip *z = (Zip *)pol->stmts[from_line].op;

    // The return code
    string code="";

    vector<string> key = z->key;
    string input1 = z->input1;
    string input2 = z->input2;
    bool itself = input1==input2;
    assert(this->in_registers_reduce_result(pol, from_line, input1) && this->in_registers_reduce_result(pol, from_line, input2));
    // all keys must be in the metadata_bus
    for (auto item: key)
        assert(this->in_metadata(item));

    // Check whether the zip is across switches
    bool input1_cross = check_zip_cross(pol, input1);
    bool input2_cross = check_zip_cross(pol, input2);
    if (input1_cross && input2_cross) {
        // We use another set of register to store the sync'ed state, add these registers here
        string reg_prefix = input1;
        for (int i=0; i<3; i++)
            assert(this->registers.add_register(Register(reg_prefix+"_s"+to_string(i), 32, 65536)));
    }

    // add metadata
    if (itself){
        assert(this->metadata.add_field(MetadataField(input1+"1_val", 32)));
        assert(this->metadata.add_field(MetadataField(input2+"2_val", 32)));
    } else {
        assert(this->metadata.add_field(MetadataField(input1+"_val", 32)));
        assert(this->metadata.add_field(MetadataField(input2+"_val", 32)));
    }

    Reduce *r_ingress_name = (Reduce*)pol->stmts[get_zip_reduce_line(pol, z->input1)].op;
    Reduce *r_egress_name = (Reduce*)pol->stmts[get_zip_reduce_line(pol, z->input2)].op;
    string ingress_name, egress_name;
    ingress_name = "reduce_"+r_ingress_name->value+"_to_"+r_ingress_name->result;
    egress_name = "reduce_"+r_egress_name->value+"_to_"+r_egress_name->result;

    // generate code
    string indent1 = "                ";
    string indent2 = "                                ";
    code += indent1+"zip_"+input1+"_"+input2+".apply(hdr, meta, standard_metadata, \\\n";
    code += indent2+ingress_name+"_full_wind, \\\n";
    if (!itself)
        code += indent2+egress_name+"_full_wind, \\\n";

    if (input1_cross && input2_cross) {
        code += indent2+input1+"_s0, \\\n";
        code += indent2+input1+"_s1, \\\n";
        code += indent2+input1+"_s2, \\\n";
    } else {
        code += indent2+ingress_name+"_s0_w0, "+ingress_name+"_s1_w0, "+ingress_name+"_s2_w0, \\\n";
        code += indent2+ingress_name+"_s0_w1, "+ingress_name+"_s1_w1, "+ingress_name+"_s2_w1, \\\n";
        code += indent2+ingress_name+"_s0_w2, "+ingress_name+"_s1_w2, "+ingress_name+"_s2_w2, \\\n";
        if (itself)
            code += indent2+ingress_name+"_s0_w3, "+ingress_name+"_s1_w3, "+ingress_name+"_s2_w3);\n";
    }
    if (!itself) {
        code += indent2+egress_name+"_s0_w0, "+egress_name+"_s1_w0, "+egress_name+"_s2_w0, \\\n";
        code += indent2+egress_name+"_s0_w1, "+egress_name+"_s1_w1, "+egress_name+"_s2_w1, \\\n";
        code += indent2+egress_name+"_s0_w2, "+egress_name+"_s1_w2, "+egress_name+"_s2_w2);\n";
    }

    string fname;
    if (input1_cross && input2_cross)
        fname = "./templates/template_zip_cross.p4";
    else
        if (itself)
            fname = "./templates/template_zip4.p4";
        else
            fname = "./templates/template_zip.p4";

    // generate func_code
	string code_zip = read_file(fname);
    code_zip = regex_replace(code_zip, regex("input1_name"), ingress_name);
    code_zip = regex_replace(code_zip, regex("input2_name"), egress_name);
    code_zip = regex_replace(code_zip, regex("input1"), input1);
    code_zip = regex_replace(code_zip, regex("input2"), input2);
    if (itself){
        code_zip = regex_replace(code_zip, regex("input_name"), ingress_name);
        code_zip = regex_replace(code_zip, regex("input"), input1);
    }

    string key_comb="";
    for (auto item : key)
        key_comb += "meta."+item + ",";
    key_comb.pop_back();
    code_zip = regex_replace(code_zip, regex("reg_key"), key_comb);

    // set size
    int input1_line_r = get_zip_reduce_line(pol, z->input1);
    Reduce *r_size = (Reduce*)pol->stmts[input1_line_r].op;
    string reg_size = "reduce_"+r_size->value+"_to_"+r_size->result + "_size";
    transform(reg_size.begin(),reg_size.end(),reg_size.begin(),::toupper);
    code_zip = regex_replace(code_zip, regex("reg_size"), reg_size);
    this->code_func += code_zip;
    return code;
}


#endif